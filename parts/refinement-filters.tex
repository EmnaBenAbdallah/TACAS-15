\section{Refinement of a genrated PH model }
The Algorithm \ref{alg:PHG_ap} return a PH model with a set of actions compeletely coherent with the observations as well as the regulatory genes influences.
But in practice this set of actions can be further refined using a background knowledge.
The following filtering operation can help to reduce the complexity of the model learned/revised.

\subsection{$1^{st}$ filter: priority on given model}

If we want to minimize the number of actions added to the input PH we can consider that the action of this PH are more trustable than the generated one. Thus generated actions that only explain changes that can already be explain by given action can be discarded: $\forall t \in T$ such that $\exists$  \texttt{change(t)}, we have:
\begin{itemize}
\item[-] \texttt{$H_c$}: the set of candidates action generated to explain $change(t)$
\item[-] \texttt{$H_{ini}$:} the set of actions of $PH_{ini}$ that can realize the change at $t$
\item[-] \texttt{$H_{final}$:} the set of actions to keep as to explain the change at $t$
\end{itemize}
We have either:
\begin{itemize}
\item[•] If $H_c \cap H_{ini} \neq \emptyset $ then $H_{final}= H_c \cap H_{ini}$ 
\item[•] If $H_c \cap H_{ini} = \emptyset $ then $H_{final}=H_c$
\end{itemize}
In practice, the change that already can be explained by the input PH can be detected before computing the candidates actions, allowing us to discard them without generating them.
If in our running example,
we start with $H_{ini}=\{h_ini\PHfrappedelay{a_0}{1}{z_1}{z_0}\}$,
since the action $h_ini$ can realize $change(6)$ there is no need to generate new ones.
Here, $H_{change(6)}$ will only consist of $h_ini = h_6$, $h_7=\PHfrappedelay{b_0}{1}{z_1}{z_0}$ and $h_8=\PHfrappedelay{a_0 \wedge b_0 }{1}{z_1}{z_0} $ will be discarded. 

\subsection{$2^{nd}$ filter: strict influences (activator or inhibitor)}

If knowledge about strict influences is given it can be used to discarded actions that are conflicting with those influences.
For example, if we know that a gene $a$ influences a gene $b$ and that $a$ can only inhibit $b$, then the actions using $a$ as hitter to increase the value of $b$ are inconsistent and can be discarded.
$\forall h \in H$ such $h=\PHfrappedelay{A}{D}{b_n}{b_m}$, with $ A \in \PHl^{\diamond}, | A| \leq i$ ($i$: indegree of the algorithm) we have :

\begin{itemize}
\item[•] If $n < m$, if $\exists G_k \in \PHl_G $ such that $G_k \xrightarrow{(-)} b$ (and $\nexists G_k \xrightarrow{(+)} b$ ) and $k \neq 0$ then $h$ can be discarded.
\item[•] If $n > m$, if $\exists G_k \in \PHl_G $ such that $G_k \xrightarrow{(+)} b$ (and $\nexists G_k \xrightarrow{(-)} b$ ) and $k \neq 0$ then $h$ can be discarded.
\end{itemize} 

In our running example, if we now that $b$ is an inhibitor of $z$, all actions where $a$ is used to activate $z$ can be discarded.
Here, we have an observation where $z$ is activated in $change(2)$ where its value switches from $z_0$ to $z_1$.
We now that $a$ as an influence on $z$ but as an inhibitor not as an activator thus the actions $h_2=\PHfrappedelay{b_1}{2}{z_0}{z_1}$ and $h_3=\PHfrappedelay{a_0 \wedge b_1 }{2}{z_0}{z_1}$ will be discarded.

\subsection{$3^rd$ filter: delay merging}

When the time information of observation is not perfect, the same regulation interaction may append with different delay.
One simple solution to deal with such input can be to simply agregate action that differ only by their delay.
We can merge each action with the same hitters, $S_1,P_1,\ldots, S_n,P_n$ and the same target, $G, P, P'$, into one action where the delay is the average.
$\forall h_1, h_2,..., h_k \in H$ such that $h_1=\PHfrappedelay{A}{D_1}{a_n}{a_m}$, $h_2=\PHfrappedelay{A}{D_2}{a_n}{a_m}$, ..., $h_k=\PHfrappedelay{A}{D_k}{a_n}{a_m}$ with $ A \in \PHl^{\diamond}$, $a_n, a_m \in \PHl_a$ et $D_1 \neq D_2 \neq ... \neq D_k$ then : \\
\texttt{fusion} all actions $h_1, h_2,..., h_k$ into one action $h$ $$h=\PHfrappedelay{A}{D_{average}}{a_n}{a_m}$$ such that: 
$$D_{average} = \frac{\sum_{i=1}^k D_{i}}{k} $$

For example, lets suppose that we came out with two actions $h=\PHfrappedelay{a_0}{2}{z_0}{z_1}$ and $h'=\PHfrappedelay{a_0 \wedge b_1 }{4}{z_0}{z_1}$, they will merged into $h_2=\PHfrappedelay{b_1}{3}{z_0}{z_1}$.
If input data are perfect, usage of this merging is totally unsafe and can lead to a set of actions that cannot produce any of the observed changes in the worst case.
The intuition behind this method is to give a first idea of how to cope with big amount of real data which are not perfect.
The idea is that if enough observations are provided, the delay of the action will be more precise.
